/**
 * Short Code Generator Tests
 *
 * Tests for short code generation and validation:
 * - generateShortCode: Cryptographic random code generation
 * - generateUniqueShortCode: Unique code generation with existence check
 * - isValidShortCode: Code format validation
 */

const {
  generateShortCode,
  generateUniqueShortCode,
  isValidShortCode,
  CODE_LENGTH,
  CHARSET
} = require('../../src/utils/shortCode');

describe('Short Code Generator', () => {
  describe('Constants', () => {
    it('should export CODE_LENGTH as 8', () => {
      expect(CODE_LENGTH).toBe(8);
    });

    it('should export CHARSET with 62 characters', () => {
      expect(CHARSET.length).toBe(62);
      expect(CHARSET).toMatch(/^[a-zA-Z0-9]+$/);
    });
  });

  describe('generateShortCode', () => {
    it('should generate code of correct length', () => {
      const code = generateShortCode();
      expect(code.length).toBe(CODE_LENGTH);
    });

    it('should generate code with only valid characters', () => {
      const code = generateShortCode();
      for (const char of code) {
        expect(CHARSET).toContain(char);
      }
    });

    it('should generate unique codes on subsequent calls', () => {
      const codes = new Set();
      for (let i = 0; i < 100; i++) {
        codes.add(generateShortCode());
      }
      // All 100 codes should be unique (probability of collision is negligible)
      expect(codes.size).toBe(100);
    });

    it('should return a string', () => {
      const code = generateShortCode();
      expect(typeof code).toBe('string');
    });

    it('should generate URL-safe codes', () => {
      const code = generateShortCode();
      // Should not contain URL-unsafe characters
      expect(code).not.toMatch(/[^a-zA-Z0-9]/);
    });
  });

  describe('generateUniqueShortCode', () => {
    it('should return code when it does not exist', async () => {
      const existsCheck = jest.fn().mockResolvedValue(false);

      const code = await generateUniqueShortCode(existsCheck);

      expect(code.length).toBe(CODE_LENGTH);
      expect(existsCheck).toHaveBeenCalledTimes(1);
    });

    it('should retry when code exists', async () => {
      // First two codes exist, third one is unique
      const existsCheck = jest.fn()
        .mockResolvedValueOnce(true)
        .mockResolvedValueOnce(true)
        .mockResolvedValueOnce(false);

      const code = await generateUniqueShortCode(existsCheck);

      expect(code.length).toBe(CODE_LENGTH);
      expect(existsCheck).toHaveBeenCalledTimes(3);
    });

    it('should throw after max attempts', async () => {
      const existsCheck = jest.fn().mockResolvedValue(true);

      await expect(generateUniqueShortCode(existsCheck, 5))
        .rejects
        .toThrow('Failed to generate unique short code after 5 attempts');

      expect(existsCheck).toHaveBeenCalledTimes(5);
    });

    it('should use default max attempts of 10', async () => {
      const existsCheck = jest.fn().mockResolvedValue(true);

      await expect(generateUniqueShortCode(existsCheck))
        .rejects
        .toThrow('Failed to generate unique short code after 10 attempts');

      expect(existsCheck).toHaveBeenCalledTimes(10);
    });

    it('should pass generated code to existsCheck', async () => {
      const existsCheck = jest.fn().mockResolvedValue(false);

      const code = await generateUniqueShortCode(existsCheck);

      expect(existsCheck).toHaveBeenCalledWith(code);
    });
  });

  describe('isValidShortCode', () => {
    it('should return true for valid 8-character alphanumeric code', () => {
      expect(isValidShortCode('abCD1234')).toBe(true);
    });

    it('should return true for codes generated by generateShortCode', () => {
      const code = generateShortCode();
      expect(isValidShortCode(code)).toBe(true);
    });

    it('should return false for null', () => {
      expect(isValidShortCode(null)).toBe(false);
    });

    it('should return false for undefined', () => {
      expect(isValidShortCode(undefined)).toBe(false);
    });

    it('should return false for empty string', () => {
      expect(isValidShortCode('')).toBe(false);
    });

    it('should return false for code too short', () => {
      expect(isValidShortCode('abc123')).toBe(false);
    });

    it('should return false for code too long', () => {
      expect(isValidShortCode('abcd12345678')).toBe(false);
    });

    it('should return false for code with invalid characters', () => {
      expect(isValidShortCode('abc!@#12')).toBe(false);
    });

    it('should return false for code with spaces', () => {
      expect(isValidShortCode('abc 1234')).toBe(false);
    });

    it('should return false for code with underscores', () => {
      expect(isValidShortCode('abc_1234')).toBe(false);
    });

    it('should return false for code with hyphens', () => {
      expect(isValidShortCode('abc-1234')).toBe(false);
    });

    it('should return false for non-string input', () => {
      expect(isValidShortCode(12345678)).toBe(false);
    });

    it('should return false for array input', () => {
      expect(isValidShortCode(['a', 'b', 'c', 'd', '1', '2', '3', '4'])).toBe(false);
    });

    it('should accept all lowercase codes', () => {
      expect(isValidShortCode('abcdefgh')).toBe(true);
    });

    it('should accept all uppercase codes', () => {
      expect(isValidShortCode('ABCDEFGH')).toBe(true);
    });

    it('should accept all numeric codes', () => {
      expect(isValidShortCode('12345678')).toBe(true);
    });

    it('should accept mixed case codes', () => {
      expect(isValidShortCode('AbCdEfGh')).toBe(true);
    });
  });
});
